int open(const char *name, int flg, [int mode])
O_RDONLY
O_WRONLY
O_RDWR
O_EXCL - защита от удаления

O_CREAT
O_TRUNC - уничтожить
                                                права доступа rwxrwxrwx & ~umask 022
int fd = open("f1", O_CREAT | O_TRUNC | O_WRONLY, 0777)
(O_RDWR | O_APPEND | O_CREAT, 0755)
________________________________________________________________________________________________________
                    значение змещения           смещение относительно чего
off_t lseek(int fd,          off_t,                  int m)
off_t - возвращает текющую позицию курсора
SEEK_SET - сменщение относительно начала 0
SEEK_CUR - смещение относительно данного места 1
SEEK = END - смещение относительно конца 3

размер файла n = lseek(fd, 0, 2)
fseek - перемещает указатель
lseek - находит смещение
________________________________________________________________________________________________________

бинарный файл - значения по байтам
fscanf(f, "%d", &x);
printf("%d", &x);

считываем из fd байтов nbytes в буфер buf
size_t - unsigned
ssize_t read(int fd, void *buf, size_t nbytes)  ->
        write(int fd, void *buf, size_t nbytes) <-
________________________________________________________________________________________________________

Big endian = BE             старший байт ... младший байт
Little endian = LE          младший байт ... старший байт

Старшие -> младшие

посчитать сумму 32 битныx чисел 
x = m[0] << 24 | m[1] << 16 | m[2] << 8 | m[3]

unsigned short -> бинарный файл
________________________________________________________________________________________________________

возвращеет отрацательное число в случае ошибки (int)
stat - следует по символическим ссылкам (на который)
lstat - не следует по символическим ссылкам (именно на указанный файл)
fstat - когда файл уже открыт (один из аргументов - файловый дескрипрот)

struct stat 
{
    ino_t st_ino; - номер индексного дескриптора
    dev_t st_dev; - номер устройства
    mode_t st_mode; - [___|rwxrwxrwx]
    nlink_t st_nlink; - число жестких связей
    uid_t st_uid; - идентификатор пользователя, создавшего файл
    gid_t st_gid; - группа пользователей, связанная с пользователем, создавшим файл
    off_t st_size; - размер файла в байтах
    time_t st_atime; - время последнего чтения
    time_t st_mtime; - время последней записи
    time_t st_ctime; - время последнего изменения метаданных
}


struct stat buf;

if (lstat("name", &buf) < 0) exit(1);
if (s_ISSREG(buf.st_mode))

s_ISREG регулярный - обычный файл
s_ISDIR - директория
s_ISLNK - символическая связь
s_ISCHR - символ
s_ISBLK - блок, модуль

if (S_ISREG(buf.st_mode)) - регулярный файл
    S_ISDIR(buf.st_mode) - директория
    S_ISLNK(buf.st_mode) - символическая связь
    S_ISCHR(buf.st_mode) - устройство символьного типа
    S_ISBLK(buf.st_mode) - устройство блочного типа
________________________________________________________________________________________________________

(врямя в типах long - абсолютное время с января 1970)
off_t st_sizes {
    time_t st_atime - последнего чтения
    time_t st_mtime - последней записи
    time_t st_ctime - последнего измения метаданных
}

char m[] = 'r-xrwxrwx'
uid_t getuid(void) - возвращает идентификатор пользователья, запустившего данную программу (реальный)
gid_t getgid(void) - группу пользователя
uid_t geteuid(void) - эффективный идентификатор пользователя (чтобы для системных команд повысить ранг) установлен ли s бит в st_mode
________________________________________________________________________________________________________

int access(const char *name, int mode) - файл проверяется на то, что с ним можно делать
mode:
F_OK 0- существует ли (отрацательное цисло - его нет)
R_OK 4
W_OK 2
X_OK 1 - выполняется ли

name:
st_uid
get_uid
если (st_uid == get_uid, то проверяем только rwx в левой части)
0 - ok 
<0 - ошибка


возвращает 0, если проверка прошла, иначе отрицательное число
int access(const char *name, int mode) - проверка доступа 
                             F_OK 0
                             R_OK 4 |
                             W_OK 2 |
                             X_OK 1 |
если st_uid == getuid проверяет первые 3 бита
если st_gid == getgid проверяет вторые 3 бита
иначе - последние 3 бита 

________________________________________________________________________________________________________

Директории

#include <dirent.h>

DIR* opendir(const char *name)
DIR *d = opendir(argv[1])
int closedir(DIR*)

При рекурсивном обходе записываем в массив названия всех

Прочтение файлов в директории
struct dixent *dd;
while ((dd == readdiz(d)) != NULL) {

}

dd->d_name - короткое имя (нужно абсолютное)
dd->d_ino нельзя использовать (берем из структуры stat)

нужно склеить путь к директории с именем объекта:
char str[PATH_MAX]
snprintf

в каждой директории хранится 
.       - название текущей директории
..      - название родителя

rmdir - unlink
________________________________________________________________________________________________________

#include <time.h>

struct tm {
    int tm_sec; [0, 60];
    int tm_min; [0, 59];
    int tm_hour; [0, 23];
    int tm_mday; [1, 31];
    int tm_mon; [0, 11];
    int tm_year; [-1900];

    int tm_wday; [0, 6] 0-вск, 6-сб
    int tm_yday; [0, 365]
    int tm_isdst = -1 (неопределено 1-летнее. 0-зимнее. -1-неопределенное)
}

time_t time(time_t *t);
timr_t cur = time(NULL);

struct tm *localtime(const time_t *t);
struct tm *localtime_r(const time_t *t, struct tm*);

time_t mktime(struct tm *t); нормализует все поля обратное к localtime


26 мая 2021 года в 11:14:00 UTC

29 дней 12 часов 44 минуты

UTC:
localtime_r -> gmtime_r
mktime -> timegm

____________________________________________________________________________________________________

int pipe(int fd[2])
fd - закольцован
fd[0] - (указатель на чтение)
fd[1] - (указатель на запись)
Возвращает: 0 - ok, -1 - ошибка
Открываем в отце, чтобы все дети видели

Если есть незакрытые
Если есть только закрытые дескрипторы по записи, то выдаст конец файлв
RT - задача зависла (не закрыли дескриптор на чтение или запись)

read -> close -> whrite выдаст ошибку при переполнении буфера SIGPIPE

все лишние дескрипторы закрываем

____________________________________________________________________________________________________

Дублируемый дескриптор
Ссылаются на одни и те же дескрипторы на чтение и запись
А в таблице занимают разные строки
Изменить стандарт входного потока

int dup(int old);  "abc"
int dup2(int old, int new);
int fd = open("aaa", O_RDONLY);
int new = dup()

dup2(fd, 0); - подмена стандартного входного потока


== 0    для сына
> 0     для отца
< 0     ошибка